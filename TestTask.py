'''Вопрос №1

На языке Python написать алгоритм (функцию) определения четности целого числа,
который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
Объяснить плюсы и минусы обеих реализаций.

Пример:

def isEven(value):

      return value % 2 == 0'''

#Вариант 1: Использование оператора % (остаток от деления)
def isEven(value):
    return value % 2 == 0
'''Оператор % возвращает остаток от деления числа на 2.
Если остаток равен 0, число четное, иначе — нечетное.'''

#Вариант 2: Использование побитовой операции &
def isEven(value):
    return (value & 1) == 0

'''Побитовая операция & сравнивает биты числа с 1.
У четных чисел младший бит всегда 0, а у нечетных — 1.
Если результат побитовой операции & с 1 равен 0, число четное, иначе — нечетное.'''

#Плюсы и минусы:
'''Вариант 1:
Плюсы:
Простота и понятность кода.
Легко читаем и поддерживаем.
Минусы:
Операция остаток от деления может быть немного медленнее на компьютерах с ограниченными ресурсами, 
так как она требует выполнения деления.'''

'''Вариант 2:
Плюсы:
Побитовые операции обычно выполняются быстрее, чем арифметические операции, такие как деление.
Может быть более эффективным на компьютерах с ограниченными ресурсами.
Минусы:
Менее интуитивно понятен для начинающих программистов.
Может быть сложнее для чтения и понимания, особенно для тех, кто не знаком с побитовыми операциями.
(Мне пришлось познакомиться с этим методом по факту выполнения задания =) )'''

'''На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. 
Объяснить плюсы и минусы каждой реализации.

Оценивается:

Полнота и качество реализации
Оформление кода
Наличие сравнения и пояснения по быстродействию'''


#Вариант 1: На основе списка
class CircularBufferList: #Реализация буфера с использованием списка
    def __init__(self, capacity):
        self.capacity = capacity #Определяем максимальный размер буфера
        self.buffer = [None] * capacity #Создаем список заполненный None, который будет нашим буфером
        self.size = 0 #Текущее количество элементов в буфере
        self.head = 0 #Индекс начала буфера
        self.tail = 0 #Индекс конца буфера

    def is_empty(self):
        return self.size == 0 #Проверяю, пуст ли буфер

    def is_full(self):
        return self.size == self.capacity #Проверяю, заполнен ли буфер

    def enqueue(self, item): #Добавляю новый элемент в конец буфера
        if self.is_full():
            raise Exception("Buffer is full") #Проверяю, не переполнен ли буфер
        self.buffer[self.tail] = item #Записываю элемент по текущему индексу хвоста
        self.tail = (self.tail + 1) % self.capacity #Перемещаю хвост на следующую позицию (по кругу)
        self.size += 1 #Увеличиваю счетчик элементов

    def dequeue(self): #Извлекает элемент из начала буфера
        if self.is_empty():
            raise Exception("Buffer is empty") #Проверяю, не пуст ли буфер
        item = self.buffer[self.head] #Читаю элемент из начала буфера
        self.buffer[self.head] = None #Очищаю место после извлеченного элемента
        self.head = (self.head + 1) % self.capacity #Перемещаю голову на следующую позицию (по кругу)
        self.size -= 1 #Уменьшаю счетчик элементов
        return item





